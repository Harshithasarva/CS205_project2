# -*- coding: utf-8 -*-
"""project_next4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NPXckJsD5reZ5fVOYwjtVjAGnVDYFw9M
"""

import math
import copy
import time

'''calculates the euclidean distance of the points x and y 
   for the features in the feature set '''
def euclidean_distance(x,y,feature_set):
    edist = 0
    for i in feature_set:
        edist += pow((x[i]-y[i]), 2)
    edist = math.sqrt(edist)
    return edist

#returns the nearest neighbor of the left_out data point
def nearest_neighbor(data, left_out, num_instances, feature_set):
    nndist = math.inf
    nnlabel = 0
    left_out_instance = data[left_out]
    for i in range(num_instances):
        if i!=left_out:
            current_label = data[i][0]
            current_instance = data[i]
            edist = euclidean_distance(current_instance, left_out_instance, feature_set)
            if edist < nndist:
                nndist = edist
                nnlabel = current_label
    return nnlabel
    
#calculates the accuracy of each left_out point
def crossValidation(data, num_instances, feature_set):
    correct_predictions = 0.0
    #splits the data and predicts the target label
    for i in range(num_instances):
        target_label = data[i][0]
        predicted_neighbor_label = nearest_neighbor(data, i, num_instances, feature_set)
        
        if target_label == predicted_neighbor_label:
            correct_predictions += 1
    accuracy = round((correct_predictions/num_instances)*100, 2)
    return accuracy

def forward_selection(data, num_instances, num_features):
    current_feature_set = [] #tracks the features of current iteration
    final_feature_set = [] #to store the best feature set
    best_accuracy = 0 #to store the best accuracy
    local_best_features = [] #to store features in the iteration
    print("\n")
    for i in range(num_features):
        local_accuracy = 0
        current_feature_set = local_best_features
        for j in range(1, num_features+1):
            if j not in current_feature_set:
                local_set = copy.deepcopy(current_feature_set)
                local_set.append(j)
                accuracy = crossValidation(data, num_instances, local_set)
                print("     - Accuracy for the features", local_set, " --> ",accuracy, "%")
              
                if accuracy > local_accuracy:
                    local_accuracy = accuracy
                    local_best_features = copy.deepcopy(local_set)
                    
                local_set.remove(j)
        print("\n   Local best feature set is", local_best_features, "with accuracy --> ", local_accuracy, "%") 
                   
        if local_accuracy > best_accuracy:
            best_accuracy = local_accuracy
            final_feature_set = local_best_features
        print("   Best feature set so far is", final_feature_set, "with accuracy --> ", best_accuracy, "%\n") 
    return final_feature_set, best_accuracy

def backward_elimination(data, num_instances, num_features):
    feature_set = [i for i in range(1, num_features+1)]
    current_feature_set = feature_set
    final_feature_set = []
    local_best_features = feature_set
    best_accuracy = 0
    print("\n")
    for i in range(num_features-1):
        local_accuracy = 0
        current_feature_set = local_best_features
        for j in range(1, num_features+1):
            if j in current_feature_set:
                local_set = copy.deepcopy(current_feature_set)
                local_set.remove(j)
                accuracy = crossValidation(data, num_instances, local_set)
                print("     - Accuracy for the features", local_set, " --> ",accuracy, "%")
                
                if accuracy > local_accuracy:
                    local_accuracy = accuracy
                    local_best_features = copy.deepcopy(local_set)
                    
                local_set.append(j)
        print("\n   Local best feature set is", local_best_features, "with accuracy --> ", local_accuracy, "%") 
                   
        if local_accuracy > best_accuracy:
            best_accuracy = local_accuracy
            final_feature_set = local_best_features
        print("   Best feature set so far is", final_feature_set, "with accuracy --> ", best_accuracy, "%\n") 
    return final_feature_set, best_accuracy 

        
def mean_normalization(data, num_features, num_instances):
    #min-max normalization - (X-Xmin)/(Xmax-Xmin)
    #finding min and max of all the feature columns
    for i in range(1, num_features):
        r_sum = 0
        r_variance = 0
        for j in range(num_instances):
            r_sum += data[i][j]
        r_mean = r_sum/num_instances
        
        for l in range(num_instances):
            r_variance += ((data[i][l] - r_mean)**2)
        r_std = math.sqrt(r_variance/num_instances)
        
        for k in range(num_instances):
            data[i][k] = (data[i][k] - r_mean)/r_std
    return data       

if __name__ == '__main__':
    #load data
    print("Welcome to Feature Selection with Nearest Neighbor Algorithm")
    print("Data File Selection:")
    print("     1. To enter the file of your choice")
    print("     2. To use default file")
    file_choice = int(input(" Enter input"))
    if file_choice == 1:
        file_path = input(" Enter the file name")
    if file_choice == 2:
        #file_path = r"C:\Users\EndUser\Desktop\AI_project2\CS205_CalibrationData__1.txt"
        file_path = r"C:\Users\EndUser\Desktop\AI_project2\CS205_SP_2022_SMALLtestdata__11.txt"
        #file_path = r"C:\Users\EndUser\Desktop\AI_project2\CS205_SP_2022_Largetestdata__75.txt"
        print("Using default file -->", file_path)
      
    #converts the rows into strings
    lines = []
    with open(file_path) as f:
        lines = f.readlines()
    data = []
    for line in lines:
        data.append(list(map(float, line.split())))
       
    #analyses data
    print("\nAnalyzing the data...")
    num_instances = len(data)
    num_features =  len(data[0])-1
    print("     Number of instances -->", num_instances)
    print("     Number of features --> ", num_features)
    classes = set()
    for i in data:
        classes.add(i[0])
    print("     Number of classes -->", len(classes))

    
    print("\nSelect the choice of feature selection to use for Nearest Neighbor Algorithm:")
    alg_choice = int(input("     1. Forward Selection\n     2. Backward Elimination\n     3. Both\n     "))    
    
    #calculates accuracy over the entire feature set
    #default feature set to include all the features
    feature_set = [i for i in range(1, num_features+1)]
    accuracy = crossValidation(data, num_instances, feature_set)
    print("Accuracy using all the features is", accuracy , "%\n")
    
    
    start_time = time.time()
    print("start time is", time.asctime( time.localtime(time.time()) ))
    if alg_choice == 1:
        print("Implementing Nearest Neighbor Algorithm using Forward Selection...")
        feature_set, forward_best = forward_selection(data, num_instances, num_features)
        print("**** Accuracy using forward selection is", forward_best, "%","for the features", feature_set)
        
    if alg_choice == 2:
        print("Implementing Nearest Neighbor Algorithm using Backward Elimination...")
        feature_set, backward_best = backward_elimination(data, num_instances, num_features)
        print("**** Accuracy using backward elimination is", backward_best, "%", "for the features", feature_set)

    print("time taken to complete this algorithm", time.time()-start_time , " ****")



